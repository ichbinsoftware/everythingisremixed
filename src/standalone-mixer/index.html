<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Everything is Remixed | Software-Entwicklungskit</title>
  <script>document.documentElement.setAttribute('data-theme', localStorage.getItem('evr-theme') || 'dark');</script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root, :root[data-theme="dark"] {
      --bg-primary: #000;
      --bg-secondary: #0a0a0a;
      --bg-tertiary: #111;
      --border: #1a1a1a;
      --text-primary: #fff;
      --text-secondary: #888;
      --text-muted: #555;
      --accent-cyan: #4ECDC4;
      --accent-yellow: #FFE66D;
      --accent-orange: #FF6B35;
      --accent-red: #ff4444;
    }

    :root[data-theme="light"] {
      --bg-primary: #f0f0f0;
      --bg-secondary: #e8e8e8;
      --bg-tertiary: #ddd;
      --border: #ccc;
      --text-primary: #1a1a1a;
      --text-secondary: #555;
      --text-muted: #888;
    }

    body {
      min-height: 100vh;
      background: linear-gradient(180deg, var(--bg-primary) 0%, #050508 100%);
      color: var(--text-primary);
      font-family: 'IBM Plex Sans', -apple-system, sans-serif;
      line-height: 1.5;
    }

    :root[data-theme="light"] body {
      background: linear-gradient(180deg, var(--bg-primary) 0%, #e0e0e0 100%);
    }

    .container {
      padding: 20px;
    }

    /* Mixer Header */
    .mixer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 1px;
      opacity: 0.8;
      margin-bottom: 12px;
    }

    .mixer-header > div {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 1;
    }

    .mixer-header > div:nth-child(2) {
      color: var(--accent-cyan);
      font-weight: 600;
      justify-content: center;
    }

    .mixer-header > div:nth-child(3) {
      justify-content: flex-end;
    }

    .mixer-header .theme-toggle {
      margin-left: 8px;
      padding: 0;
      background: transparent;
      border: none;
      color: var(--text-primary);
      cursor: pointer;
      width: 14px;
      height: 14px;
    }

    .mixer-header .theme-toggle svg {
      width: 14px;
      height: 14px;
    }

    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: var(--accent-cyan);
      border-radius: 50%;
      box-shadow: 0 0 10px var(--accent-cyan);
      animation: pulse 2s infinite;
      margin-right: 8px;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }

    /* Theme toggle icons */
    :root[data-theme="dark"] .moon-icon { display: none; }
    :root[data-theme="light"] .sun-icon { display: none; }
    :root[data-theme="dark"] .sun-icon { display: block; }
    :root[data-theme="light"] .moon-icon { display: block; }

    /* Upload View - Ghost Mixer */
    .upload-view {
      position: relative;
      min-height: 500px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ghost-mixer-bg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      gap: 8px;
      pointer-events: none;
    }

    .ghost-channel {
      width: 60px;
      height: 280px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #111;
      display: flex;
      flex-direction: column;
      padding: 8px;
      gap: 8px;
      animation: ghost-pulse 3s ease-in-out infinite;
    }

    .ghost-channel:nth-child(1) { animation-delay: 0s; }
    .ghost-channel:nth-child(2) { animation-delay: 0.15s; }
    .ghost-channel:nth-child(3) { animation-delay: 0.3s; }
    .ghost-channel:nth-child(4) { animation-delay: 0.45s; }
    .ghost-channel:nth-child(5) { animation-delay: 0.6s; }
    .ghost-channel:nth-child(6) { animation-delay: 0.75s; }
    .ghost-channel:nth-child(7) { animation-delay: 0.9s; }
    .ghost-channel:nth-child(8) { animation-delay: 1.05s; }

    @keyframes ghost-pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.7; }
    }

    .ghost-name {
      height: 12px;
      background: #555;
      border-radius: 2px;
    }

    .ghost-wave {
      height: 20px;
      background: #555;
      border-radius: 4px;
    }

    .ghost-fader {
      flex: 1;
      background: #444;
      border-radius: 4px;
      border: 1px solid #555;
    }

    .ghost-btns {
      display: flex;
      gap: 4px;
    }

    .ghost-btn {
      flex: 1;
      height: 20px;
      background: #555;
      border-radius: 4px;
    }

    /* Light mode ghost channels */
    :root[data-theme="light"] .ghost-channel {
      border-color: #ccc;
      background: #e5e5e5;
    }

    :root[data-theme="light"] .ghost-name,
    :root[data-theme="light"] .ghost-wave,
    :root[data-theme="light"] .ghost-btn {
      background: #ccc;
    }

    :root[data-theme="light"] .ghost-fader {
      background: #ccc;
      border-color: #bbb;
    }

    /* Floating particles */
    .particles-bg {
      position: absolute;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      animation: float-particle 8s ease-in-out infinite;
    }

    .particle:nth-child(1) { left: 5%; top: 20%; background: var(--accent-cyan); animation-delay: 0s; }
    .particle:nth-child(2) { left: 15%; top: 70%; background: var(--accent-yellow); animation-delay: 1s; }
    .particle:nth-child(3) { left: 25%; top: 35%; background: var(--accent-cyan); animation-delay: 2s; }
    .particle:nth-child(4) { left: 75%; top: 65%; background: var(--accent-orange); animation-delay: 3s; }
    .particle:nth-child(5) { left: 85%; top: 25%; background: var(--accent-yellow); animation-delay: 4s; }
    .particle:nth-child(6) { left: 95%; top: 50%; background: var(--accent-cyan); animation-delay: 5s; }
    .particle:nth-child(7) { left: 10%; top: 85%; background: var(--accent-orange); animation-delay: 6s; }
    .particle:nth-child(8) { left: 90%; top: 80%; background: var(--accent-yellow); animation-delay: 7s; }

    @keyframes float-particle {
      0%, 100% { transform: translateY(0) scale(1); opacity: 0.3; }
      50% { transform: translateY(-25px) scale(1.3); opacity: 0.6; }
    }


    .ghost-name {
      height: 12px;
      background: var(--border);
      border-radius: 2px;
    }

    .ghost-wave {
      height: 20px;
      background: var(--border);
      border-radius: 4px;
    }

    .ghost-fader {
      flex: 1;
      background: var(--border);
      border-radius: 4px;
    }

    .ghost-btns {
      display: flex;
      gap: 4px;
    }

    .ghost-btn {
      flex: 1;
      height: 20px;
      background: var(--border);
      border-radius: 4px;
    }

    /* Upload Overlay */
    .upload-overlay {
      position: relative;
      z-index: 1;
      text-align: center;
    }

    .upload-overlay h3 {
      font-size: 22px;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    .upload-overlay p {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 24px;
    }

    .drop-btn {
      display: inline-block;
      padding: 16px 32px;
      border: 2px dashed var(--accent-cyan);
      border-radius: 12px;
      color: var(--accent-cyan);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      background: transparent;
      font-family: inherit;
    }

    .drop-btn:hover,
    .upload-overlay.dragover .drop-btn {
      background: rgba(78, 205, 196, 0.1);
      border-style: solid;
    }

    .drop-formats {
      margin-top: 16px;
      font-size: 11px;
      color: var(--text-secondary);
      letter-spacing: 1px;
    }

    .upload-overlay input[type="file"] {
      display: none;
    }

    .upload-overlay.has-files .drop-btn {
      border-style: solid;
      border-color: var(--accent-cyan);
      background: rgba(78, 205, 196, 0.1);
    }

    .upload-overlay.has-files .drop-formats {
      display: none;
    }

    .file-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 16px;
    }

    .file-tag {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 12px;
      font-family: 'IBM Plex Mono', monospace;
    }

    .file-tag .status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-cyan);
    }

    /* Mixer Panel */
    .mixer-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      display: none;
    }

    .mixer-panel.visible {
      display: block;
    }

    /* Track Info */
    .track-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .track-info h2 {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 4px;
      outline: none;
      padding: 2px 6px;
      margin-left: -6px;
      border-radius: 4px;
      border: 1px solid transparent;
      transition: border-color 0.2s;
    }

    .track-info h2:hover {
      border-color: var(--border);
    }

    .track-info h2:focus {
      border-color: var(--accent-cyan);
    }

    .track-meta {
      font-size: 12px;
      color: var(--text-secondary);
      font-family: 'IBM Plex Mono', monospace;
    }

    .time-start {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      font-weight: 500;
      color: var(--accent-cyan);
      font-variant-numeric: tabular-nums;
      flex-shrink: 0;
    }

    .time-end {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      font-variant-numeric: tabular-nums;
      flex-shrink: 0;
    }

    /* Master Waveform */
    .master-waveform {
      margin-bottom: 16px;
    }

    .master-waveform canvas {
      width: 100%;
      height: 80px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg-primary);
    }

    /* Progress Bar */
    .progress-container {
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .progress-bar {
      flex-grow: 1;
      height: 6px;
      background: var(--border);
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-yellow));
      border-radius: 3px;
      transition: width 0.1s linear;
      position: relative;
    }

    .progress-handle {
      position: absolute;
      right: -7px;
      top: 50%;
      transform: translateY(-50%);
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }

    /* Channel Strip */
    .channels-container {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      overflow-y: visible;
      padding-bottom: 12px;
      margin-bottom: 24px;
      scrollbar-width: thin;
      scrollbar-color: var(--border) var(--bg-primary);
    }
    .channels-container::-webkit-scrollbar { height: 8px; }
    .channels-container::-webkit-scrollbar-track { background: var(--bg-primary); border-radius: 4px; }
    .channels-container::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

    .channel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px 8px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      min-width: 70px;
      max-width: 70px;
      flex-shrink: 0;
      transition: all 0.2s;
    }

    .channel.active {
      border-color: var(--channel-color);
      box-shadow: 0 0 20px color-mix(in srgb, var(--channel-color) 20%, transparent);
    }

    .channel.inactive {
      opacity: 0.4;
    }

    /* Element Tile */
    .element-tile {
      width: 48px;
      height: 48px;
      border: 2px solid var(--channel-color);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      background: linear-gradient(135deg, 
        color-mix(in srgb, var(--channel-color) 10%, transparent),
        color-mix(in srgb, var(--channel-color) 20%, transparent)
      );
    }

    .element-tile .atomic-num {
      position: absolute;
      top: 3px;
      left: 5px;
      font-size: 8px;
      color: var(--channel-color);
      opacity: 0.7;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 500;
    }

    .element-tile .symbol {
      font-size: 22px;
      font-weight: 700;
      color: var(--channel-color);
      font-family: 'IBM Plex Mono', monospace;
    }

    .channel-name {
      font-size: 8px;
      font-weight: 600;
      color: var(--text-secondary);
      letter-spacing: 0.5px;
      font-family: 'IBM Plex Mono', monospace;
      text-transform: uppercase;
      text-align: center;
      line-height: 1.3;
      max-width: 100%;
      min-height: 21px;
      max-height: 21px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .channel.active .channel-name {
      color: var(--text-primary);
    }

    /* Signal LED */
    .signal-led {
      display: block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #333;
      margin: 0 auto 4px;
      transition: background 0.1s, box-shadow 0.1s;
    }

    .channel.has-signal .signal-led {
      background: var(--channel-color);
      box-shadow: 0 0 8px var(--channel-color);
    }

    .channel.has-signal .channel-name {
      text-shadow: 0 0 6px var(--channel-color);
    }

    :root[data-theme="light"] .signal-led {
      background: #ccc;
    }

    :root[data-theme="light"] .stem-waveform {
      background: #e0e0e0;
    }

    :root[data-theme="light"] .holograph-container {
      background: #e0e0e0;
    }

    :root[data-theme="light"] .channel-btn {
      background: var(--border);
      color: var(--text-secondary);
    }

    :root[data-theme="light"] .channel-btn:hover {
      background: #bbb;
      color: var(--text-primary);
    }

    :root[data-theme="light"] .channel-btn.solo.active {
      background: var(--accent-yellow);
      color: #000;
    }

    :root[data-theme="light"] .channel-btn.fx-btn {
      background: var(--border);
    }

    :root[data-theme="light"] .channel-btn.fx-btn:hover {
      background: #bbb;
    }

    /* Stem Waveform */
    .stem-waveform {
      width: 100%;
      height: 28px;
      background: #111;
      border-radius: 4px;
      overflow: hidden;
    }

    .stem-waveform canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Fader */
    .fader-container {
      display: flex;
      gap: 6px;
      align-items: stretch;
    }

    .meter {
      width: 3px;
      height: 80px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }

    .meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100%;
      background: var(--channel-color);
      transform-origin: bottom;
      transform: scaleY(0);
      transition: transform 0.05s;
      will-change: transform;
    }

    .fader {
      width: 10px;
      height: 80px;
      background: var(--border);
      border-radius: 5px;
      position: relative;
      cursor: pointer;
      border: 1px solid #333;
    }

    .fader-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, 
        color-mix(in srgb, var(--channel-color) 40%, transparent),
        color-mix(in srgb, var(--channel-color) 70%, transparent)
      );
      border-radius: 5px;
      transition: height 0.05s;
    }

    .fader-handle {
      position: absolute;
      left: 50%;
      transform: translate(-50%, 50%);
      width: 22px;
      height: 10px;
      background: linear-gradient(180deg, var(--channel-color), color-mix(in srgb, var(--channel-color) 80%, black));
      border-radius: 3px;
      box-shadow: 0 2px 8px color-mix(in srgb, var(--channel-color) 50%, transparent);
      transition: bottom 0.05s;
    }

    /* Volume Readout */
    .volume-readout {
      font-size: 10px;
      color: var(--text-muted);
      font-family: 'IBM Plex Mono', monospace;
      font-variant-numeric: tabular-nums;
    }

    /* Mute/Solo Buttons */
    .channel-buttons {
      display: flex;
      gap: 4px;
    }

    .channel-btn {
      width: 28px;
      height: 22px;
      border: none;
      border-radius: 3px;
      background: #222;
      color: var(--text-muted);
      font-size: 9px;
      font-weight: 700;
      font-family: 'IBM Plex Mono', monospace;
      cursor: pointer;
      transition: all 0.15s;
    }

    .channel-btn:hover {
      background: #333;
    }

    .channel-btn.mute.active {
      background: #666;
      color: #fff;
    }

    .channel-btn.solo.active {
      background: var(--accent-yellow);
      color: #000;
    }

    /* Transport */
    .transport {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
    }

    .transport-btn {
      width: 48px;
      height: 48px;
      border: none;
      border-radius: 8px;
      background: var(--border);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .transport-btn:hover {
      background: #222;
      color: var(--text-primary);
    }

    .transport-btn.play {
      width: 64px;
      height: 64px;
      border-radius: 32px;
      background: #fff;
      color: #000;
      box-shadow: 0 4px 20px rgba(255,255,255,0.25);
    }

    .transport-btn.play:hover {
      transform: scale(1.05);
    }

    .transport-btn svg {
      width: 20px;
      height: 20px;
    }

    .transport-btn.play svg {
      width: 28px;
      height: 28px;
    }

    /* Actions */
    .actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 24px;
    }

    .action-btn {
      padding: 14px 28px;
      border: 1px solid #333;
      border-radius: 10px;
      background: transparent;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      font-family: inherit;
    }

    .action-btn:hover {
      border-color: #555;
      color: var(--text-primary);
    }

    .action-btn.primary {
      border: none;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-yellow));
      color: #000;
      font-weight: 600;
    }

    .action-btn.primary:hover {
      opacity: 0.9;
    }

    .action-btn.primary.success {
      background: var(--accent-cyan);
    }

    #backBtn {
      padding: 14px 20px;
      font-weight: 600;
    }

    /* Share URL */
    .share-section {
      padding: 18px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      margin-bottom: 24px;
    }

    .share-section label {
      display: block;
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 10px;
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing: 1px;
    }

    .share-url {
      display: block;
      width: 100%;
      padding: 14px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 11px;
      color: var(--accent-cyan);
      font-family: 'IBM Plex Mono', monospace;
      word-break: break-all;
      resize: none;
      outline: none;
    }

    /* Footer */
    footer {
      padding-top: 24px;
      border-top: 1px solid var(--border);
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    footer a {
      color: var(--text-secondary);
      text-decoration: none;
    }

    footer a:hover {
      color: var(--text-primary);
    }


    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 16px;
      }

      header {
        flex-direction: column;
        gap: 16px;
        text-align: center;
      }

      .track-header {
        flex-direction: column;
        gap: 12px;
        text-align: center;
      }

      .channels-container {
        justify-content: flex-start;
      }
    }

    /* Loading state */
    .loading-section {
      display: none;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 48px 24px;
      margin-bottom: 24px;
      text-align: center;
    }

    .loading-section.visible {
      display: block;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid var(--border);
      border-top-color: var(--accent-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 20px;
    }

    .loading-progress-container {
      max-width: 400px;
      margin: 0 auto;
    }

    .loading-progress-bar {
      height: 8px;
      background: var(--border);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .loading-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-yellow));
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }

    .loading-percent {
      font-size: 12px;
      color: var(--accent-cyan);
      font-family: 'IBM Plex Mono', monospace;
      font-variant-numeric: tabular-nums;
    }

    /* Hide upload view when mixer visible */
    .upload-view.hidden {
      display: none;
    }

    /* FX Modal */
    .fx-modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      backdrop-filter: blur(4px);
    }

    .fx-modal-backdrop.active {
      opacity: 1;
      visibility: visible;
    }

    .fx-modal {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transform: scale(0.95) translateY(10px);
      transition: transform 0.2s;
    }

    .fx-modal-backdrop.active .fx-modal {
      transform: scale(1) translateY(0);
    }

    .fx-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .fx-modal-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-cyan);
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing: 1px;
    }

    .fx-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      line-height: 1;
    }

    .fx-close:hover {
      color: var(--text-primary);
    }

    .fx-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .fx-tab-btn {
      flex: 1;
      padding: 12px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing: 0.5px;
      transition: color 0.2s;
    }

    .fx-tab-btn:hover {
      color: var(--text-primary);
    }

    .fx-tab-btn.active {
      color: var(--accent-cyan);
      border-bottom-color: var(--accent-cyan);
    }

    .fx-modal-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .fx-tab-content {
      display: none;
    }

    .fx-tab-content.active {
      display: block;
    }

    .fx-section {
      margin-bottom: 20px;
    }

    .fx-section:last-child {
      margin-bottom: 0;
    }

    .fx-section-label {
      display: block;
      font-size: 9px;
      color: var(--text-muted);
      margin-bottom: 10px;
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .fx-control {
      display: grid;
      grid-template-columns: 55px 1fr 45px;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .fx-label {
      font-size: 10px;
      color: var(--text-secondary);
    }

    .fx-value {
      font-size: 10px;
      color: var(--accent-cyan);
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-family: 'IBM Plex Mono', monospace;
    }

    .fx-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }

    .fx-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent-cyan);
      border-radius: 50%;
      cursor: pointer;
    }

    .fx-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent-cyan);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .fx-select {
      width: 100%;
      padding: 8px 10px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 11px;
      font-family: 'IBM Plex Mono', monospace;
      outline: none;
      cursor: pointer;
    }

    .fx-select:hover {
      border-color: #333;
    }

    .fx-select:focus {
      border-color: var(--accent-cyan);
    }

    .channel-btn.fx-btn {
      width: 100%;
      margin-top: 4px;
      background: #1a1a1a;
    }

    .channel-btn.fx-btn:hover {
      background: #2a2a2a;
      color: var(--accent-cyan);
    }

    /* Holograph Visualizer */
    .holograph-container {
      position: relative;
      width: 100%;
      height: 80px;
      margin-bottom: 16px;
      border-radius: 8px;
      overflow: hidden;
      background: var(--bg-primary);
      border: 2px solid var(--accent-cyan);
    }

    .holograph-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Pan Control */
    .pan-control {
      width: 100%;
      margin-bottom: 8px;
    }

    .pan-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }

    .pan-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 10px;
      height: 10px;
      background: var(--channel-color, var(--accent-cyan));
      border-radius: 50%;
      cursor: pointer;
    }

    .pan-slider::-moz-range-thumb {
      width: 10px;
      height: 10px;
      background: var(--channel-color, var(--accent-cyan));
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .pan-label {
      font-size: 7px;
      color: var(--text-muted);
      text-align: center;
      letter-spacing: 0.5px;
      font-family: 'IBM Plex Mono', monospace;
    }

    /* Master Channel */
    .master-channel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px 8px;
      background: var(--bg-primary);
      border: 2px solid var(--accent-cyan);
      border-radius: 8px;
      min-width: 90px;
      max-width: 90px;
      box-shadow: 0 0 16px rgba(78, 205, 196, 0.25);
      margin-left: 16px;
      flex-shrink: 0;
    }

    .master-label {
      font-size: 10px;
      font-weight: 700;
      color: var(--accent-cyan);
      letter-spacing: 1.5px;
      font-family: 'IBM Plex Mono', monospace;
    }

    .master-fader-container {
      display: flex;
      gap: 6px;
      align-items: stretch;
    }

    .master-meter {
      width: 5px;
      height: 240px;
      background: var(--border);
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }

    .master-meter-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100%;
      background: var(--accent-cyan);
      transform-origin: bottom;
      transform: scaleY(0);
      transition: transform 0.05s;
      will-change: transform;
    }

    .master-fader {
      width: 16px;
      height: 240px;
      background: var(--border);
      border-radius: 8px;
      position: relative;
      cursor: pointer;
      border: 1px solid #333;
    }

    .master-fader::after {
      content: '';
      position: absolute;
      top: -15px;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      z-index: 2;
    }

    .master-fader .fader-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, rgba(78, 205, 196, 0.4), rgba(78, 205, 196, 0.7));
      border-radius: 7px;
      transition: height 0.05s;
    }

    .master-fader .fader-handle {
      position: absolute;
      left: 50%;
      transform: translate(-50%, 50%);
      width: 22px;
      height: 10px;
      background: linear-gradient(180deg, var(--accent-cyan), #3BA99F);
      border-radius: 3px;
      box-shadow: 0 2px 8px rgba(78, 205, 196, 0.5);
      transition: bottom 0.05s;
    }

    .master-volume-readout {
      font-size: 11px;
      color: var(--accent-cyan);
      font-variant-numeric: tabular-nums;
      font-weight: 600;
      font-family: 'IBM Plex Mono', monospace;
    }

    /* Header Right Section */
    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* Help Button */
    .help-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      padding: 0;
      line-height: 1;
      vertical-align: middle;
      font-family: 'IBM Plex Mono', monospace;
    }

    .help-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }

    /* Help Modal / Bottom Sheet */
    .help-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .help-backdrop.active {
      opacity: 1;
      visibility: visible;
    }

    .help-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      width: 90%;
      max-width: 480px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transform: scale(0.95);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
    }

    .help-backdrop.active .help-modal {
      transform: scale(1);
      opacity: 1;
    }

    .help-handle {
      display: none;
    }

    .help-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }

    .help-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-cyan);
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing: 1px;
    }

    .help-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      width: 24px;
      height: 24px;
    }

    .help-close:hover {
      color: var(--text-primary);
    }

    .help-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      padding: 0 16px;
    }

    .help-tab {
      padding: 12px 16px;
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      font-family: 'IBM Plex Mono', monospace;
      letter-spacing: 0.5px;
      transition: color 0.2s;
    }

    .help-tab:hover {
      color: var(--text-primary);
    }

    .help-tab.active {
      color: var(--accent-cyan);
      border-bottom-color: var(--accent-cyan);
    }

    .help-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    .help-tab-content {
      display: none;
    }

    .help-tab-content.active {
      display: block;
    }

    .help-item {
      display: flex;
      gap: 12px;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }

    .help-item:last-child {
      border-bottom: none;
    }

    .help-icon {
      flex-shrink: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .help-icon-fader {
      width: 8px;
      height: 24px;
      background: linear-gradient(to top, var(--accent-cyan) 60%, var(--border) 60%);
      border-radius: 4px;
    }

    .help-icon-btns {
      display: flex;
      gap: 2px;
    }

    .help-icon-btns span {
      width: 14px;
      height: 14px;
      border-radius: 2px;
      font-size: 8px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'IBM Plex Mono', monospace;
    }

    .help-icon-btns .m-icon {
      background: var(--accent-red);
      color: #000;
    }

    .help-icon-btns .s-icon {
      background: var(--accent-yellow);
      color: #000;
    }

    .help-icon-pan {
      width: 24px;
      height: 24px;
      border: 2px solid var(--accent-cyan);
      border-radius: 50%;
      position: relative;
    }

    .help-icon-pan::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 6px;
      background: var(--accent-cyan);
      border-radius: 50%;
      top: 3px;
      left: 50%;
      transform: translateX(-50%);
    }

    .help-icon-fx {
      width: 24px;
      height: 16px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: 700;
      color: var(--accent-cyan);
      font-family: 'IBM Plex Mono', monospace;
    }

    .help-icon-led {
      width: 8px;
      height: 8px;
      background: var(--accent-cyan);
      border-radius: 50%;
      box-shadow: 0 0 8px var(--accent-cyan);
    }

    .help-icon-share {
      font-size: 18px;
    }

    .help-icon-reset {
      font-size: 16px;
    }

    .help-text h4 {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .help-text p {
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .help-shortcut {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .help-shortcut:last-child {
      border-bottom: none;
    }

    .help-shortcut-key {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 11px;
      font-family: 'IBM Plex Mono', monospace;
      color: var(--accent-cyan);
    }

    .help-shortcut-desc {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .help-tip {
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .help-tip:last-child {
      margin-bottom: 0;
    }

    .help-tip-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-yellow);
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .help-tip p {
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .help-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      text-align: center;
    }

    .help-dismiss {
      padding: 10px 24px;
      background: var(--accent-cyan);
      border: none;
      border-radius: 6px;
      color: #000;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      font-family: 'IBM Plex Mono', monospace;
    }

    .help-dismiss:hover {
      opacity: 0.9;
    }

    /* Mobile: Convert to Bottom Sheet */
    @media (max-width: 768px) {
      .help-backdrop {
        align-items: flex-end;
      }

      .help-modal {
        width: 100%;
        max-width: none;
        max-height: 85vh;
        border-radius: 16px 16px 0 0;
        transform: translateY(100%);
      }

      .help-backdrop.active .help-modal {
        transform: translateY(0);
      }

      .help-handle {
        display: block;
        width: 36px;
        height: 4px;
        background: var(--border);
        border-radius: 2px;
        margin: 8px auto;
      }

      .help-header {
        padding-top: 8px;
      }

      .help-tabs .help-tab[data-tab="shortcuts"] {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="mixer-header">
      <div>
        <span class="status-dot"></span><span id="statusText">STANDBY</span>
        <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme">
          <svg class="sun-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
            <line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
          </svg>
          <svg class="moon-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
          </svg>
        </button>
      </div>
      <div>STEM MIXER</div>
      <div>
        EVR
        <button id="helpBtn" class="help-btn" aria-label="Help">?</button>
      </div>
    </header>

    <div class="upload-view" id="uploadView">
      <div class="particles-bg">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
      </div>
      <div class="ghost-mixer-bg">
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
        <div class="ghost-channel"><div class="ghost-name"></div><div class="ghost-wave"></div><div class="ghost-fader"></div><div class="ghost-btns"><div class="ghost-btn"></div><div class="ghost-btn"></div></div></div>
      </div>

      <div class="upload-overlay" id="dropZone">
        <h3>Your mixer awaits</h3>
        <p>Add stems to bring it to life</p>
        <button class="drop-btn">+ Drop audio files</button>
        <div class="drop-formats">M4A ¬∑ MP3 ¬∑ WAV ¬∑ FLAC ¬∑ OGG</div>
        <input type="file" id="fileInput" multiple accept="audio/*,.m4a">
        <div class="file-list" id="fileList"></div>
      </div>
    </div>

    <div class="loading-section" id="loadingSection">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loadingText">Loading stems...</div>
      <div class="loading-progress-container">
        <div class="loading-progress-bar">
          <div class="loading-progress-fill" id="loadingProgressFill"></div>
        </div>
        <div class="loading-percent" id="loadingPercent">0%</div>
      </div>
    </div>

    <div class="mixer-panel" id="mixerPanel">
      <div class="track-header">
        <div class="track-info">
          <h2 id="trackName" contenteditable="true" spellcheck="false">Your Mix</h2>
          <div class="track-meta" id="trackMeta">Drop stems to begin</div>
        </div>
      </div>

      <div class="holograph-container">
        <canvas id="holographCanvas" class="holograph-canvas"></canvas>
      </div>

      <div class="progress-container">
        <span id="currentTime" class="time-start">0:00</span>
        <div class="progress-bar" id="progressBar">
          <div class="progress-fill" id="progressFill">
            <div class="progress-handle"></div>
          </div>
        </div>
        <span id="duration" class="time-end">0:00</span>
      </div>

      <div class="channels-container" id="channelsContainer"></div>

      <div class="transport">
        <button class="transport-btn" id="restartBtn" title="Restart">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
          </svg>
        </button>
        <button class="transport-btn" id="skipBackBtn" title="Back 10s">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/>
          </svg>
        </button>
        <button class="transport-btn play" id="playBtn" title="Play/Pause">
          <svg viewBox="0 0 24 24" fill="currentColor" id="playIcon">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </button>
        <button class="transport-btn" id="skipFwdBtn" title="Fwd 10s">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/>
          </svg>
        </button>
        <button class="transport-btn" id="stopBtn" title="Stop">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M6 6h12v12H6z"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="actions" id="actionsSection" style="display: none;">
      <button class="action-btn" id="backBtn">&lt;</button>
      <button class="action-btn" id="resetBtn">RESET</button>
    </div>

    <footer>
      <p><strong>Everything is Free</strong> ¬∑ CC0 1.0 Universal ¬∑ Zero Restrictions</p>
      <p style="margin-top: 8px;">
        <a href="https://github.com/ichbinsoftware/everythingisfree">GitHub</a>
        &nbsp;¬∑&nbsp;
        <a href="https://software-entwicklungskit.bandcamp.com">Bandcamp</a>
      </p>
    </footer>
  </div>

  <!-- Help Modal / Bottom Sheet -->
  <div class="help-backdrop" id="helpBackdrop">
    <div class="help-modal" id="helpModal">
      <div class="help-handle"></div>
      <div class="help-header">
        <span class="help-title">MIXER GUIDE</span>
        <button class="help-close" id="helpClose">&times;</button>
      </div>
      <div class="help-tabs">
        <button class="help-tab active" data-tab="controls">Controls</button>
        <button class="help-tab" data-tab="shortcuts">Shortcuts</button>
        <button class="help-tab" data-tab="tips">Tips</button>
      </div>
      <div class="help-content">
        <!-- Controls Tab -->
        <div class="help-tab-content active" data-tab="controls">
          <div class="help-item">
            <div class="help-icon"><div class="help-icon-fader"></div></div>
            <div class="help-text">
              <h4>Volume Fader</h4>
              <p>Drag up/down to adjust stem volume. Each channel has independent volume control.</p>
            </div>
          </div>
          <div class="help-item">
            <div class="help-icon">
              <div class="help-icon-btns">
                <span class="m-icon">M</span>
                <span class="s-icon">S</span>
              </div>
            </div>
            <div class="help-text">
              <h4>Mute & Solo</h4>
              <p><strong>M</strong> silences a stem. <strong>S</strong> solos it (mutes all others). Multiple solos play together.</p>
            </div>
          </div>
          <div class="help-item">
            <div class="help-icon"><div class="help-icon-pan"></div></div>
            <div class="help-text">
              <h4>Pan Knob</h4>
              <p>Slide left/right to position the stem in the stereo field. Center is default.</p>
            </div>
          </div>
          <div class="help-item">
            <div class="help-icon"><div class="help-icon-fx">FX</div></div>
            <div class="help-text">
              <h4>Effects (FX)</h4>
              <p>Opens EQ, Filter, Reverb, and Delay controls for that stem.</p>
            </div>
          </div>
          <div class="help-item">
            <div class="help-icon"><div class="help-icon-led"></div></div>
            <div class="help-text">
              <h4>Level Meter</h4>
              <p>Shows real-time audio level. Green bar indicates signal strength.</p>
            </div>
          </div>
          <div class="help-item">
            <div class="help-icon"><span class="help-icon-reset">‚Ü∫</span></div>
            <div class="help-text">
              <h4>Reset</h4>
              <p>Restore all stems to default volume, pan, and effects settings.</p>
            </div>
          </div>
        </div>
        <!-- Shortcuts Tab -->
        <div class="help-tab-content" data-tab="shortcuts">
          <div class="help-shortcut">
            <span class="help-shortcut-key">Space</span>
            <span class="help-shortcut-desc">Play / Pause</span>
          </div>
          <div class="help-shortcut">
            <span class="help-shortcut-key">Enter</span>
            <span class="help-shortcut-desc">Restart from beginning</span>
          </div>
          <div class="help-shortcut">
            <span class="help-shortcut-key">Esc</span>
            <span class="help-shortcut-desc">Stop playback</span>
          </div>
          <div class="help-shortcut">
            <span class="help-shortcut-key">‚Üê</span>
            <span class="help-shortcut-desc">Skip back 5 seconds</span>
          </div>
          <div class="help-shortcut">
            <span class="help-shortcut-key">‚Üí</span>
            <span class="help-shortcut-desc">Skip forward 5 seconds</span>
          </div>
          <div class="help-shortcut">
            <span class="help-shortcut-key">?</span>
            <span class="help-shortcut-desc">Toggle this help panel</span>
          </div>
        </div>
        <!-- Tips Tab -->
        <div class="help-tab-content" data-tab="tips">
          <div class="help-tip">
            <div class="help-tip-title">üí° Quick Solo</div>
            <p>Solo multiple stems to hear them together without the rest of the mix.</p>
          </div>
          <div class="help-tip">
            <div class="help-tip-title">üí° File Naming</div>
            <p>Name your files like "drums.m4a" or "bass.wav" for automatic channel assignment.</p>
          </div>
          <div class="help-tip">
            <div class="help-tip-title">üí° Master Control</div>
            <p>The MASTER fader on the right controls overall output volume.</p>
          </div>
        </div>
      </div>
      <div class="help-footer">
        <button class="help-dismiss" id="helpDismiss">Got it</button>
      </div>
    </div>
  </div>

  <!-- FX Modal -->
  <div class="fx-modal-backdrop" id="fxModalBackdrop">
    <div class="fx-modal">
      <div class="fx-modal-header">
        <span class="fx-modal-title" id="fxModalTitle">FX</span>
        <button class="fx-close" id="fxModalClose">&times;</button>
      </div>
      <div class="fx-tabs">
        <button class="fx-tab-btn active" data-tab="eq-filter">EQ / FILTER</button>
        <button class="fx-tab-btn" data-tab="reverb-delay">REVERB / DELAY</button>
      </div>
      <div class="fx-modal-content" id="fxModalContent">
        <!-- Content populated dynamically -->
      </div>
    </div>
  </div>

  <script>
    // ========================================================================
    // STEM PRESETS (for auto-detection)
    // ========================================================================

    const STEM_PRESETS = [
      { id: 'kick',    name: 'KICK',     color: '#FF6B35' },
      { id: 'snare',   name: 'SNARE',    color: '#FF8C5A' },
      { id: 'hats',    name: 'HATS',     color: '#FFB347' },
      { id: 'drums',   name: 'DRUMS',    color: '#FF6B35' },
      { id: 'perc',    name: 'PERC',     color: '#FFA07A' },
      { id: 'bass',    name: 'BASS',     color: '#4ECDC4' },
      { id: 'sub',     name: 'SUB',      color: '#26A69A' },
      { id: 'synth',   name: 'SYNTH',    color: '#FFE66D' },
      { id: 'lead',    name: 'LEAD',     color: '#FFEB3B' },
      { id: 'keys',    name: 'KEYS',     color: '#FFF59D' },
      { id: 'piano',   name: 'PIANO',    color: '#E6EE9C' },
      { id: 'pad',     name: 'PAD',      color: '#DDA0DD' },
      { id: 'pads',    name: 'PADS',     color: '#CE93D8' },
      { id: 'strings', name: 'STRINGS',  color: '#B39DDB' },
      { id: 'vox',     name: 'VOX',      color: '#F48FB1' },
      { id: 'vocal',   name: 'VOCAL',    color: '#F06292' },
      { id: 'fx',      name: 'FX',       color: '#90CAF9' },
      { id: 'atmo',    name: 'ATMO',     color: '#81D4FA' },
      { id: 'guitar',  name: 'GUITAR',   color: '#A5D6A7' },
      { id: 'other',   name: 'OTHER',    color: '#888888' },
    ];

    const DEFAULT_FX = {
      eq: { low: 0, mid: 0, high: 0 },
      filter: { type: 'lowpass', freq: 20000, q: 1, rolloff: -12 },
      reverb: 0,
      delay: { time: 0.25, feedback: 0.3, mix: 0 },
      pan: 0
    };

    const FALLBACK_COLORS = ['#FF6B35', '#4ECDC4', '#FFE66D', '#95E1D3', '#DDA0DD', '#F38181', '#AFA0EF', '#90CAF9', '#A5D6A7', '#FFAB91', '#80DEEA', '#CE93D8'];

    // ========================================================================
    // STATE
    // ========================================================================

    let audioContext = null;
    let masterGain = null;
    let masterMeter = null;
    let masterReverb = null;
    let impulseBuffer = null;
    let masterWaveformBuffer = null;

    const players = {};
    const meters = {};
    const meterBuffers = {};
    const meterElements = {};
    const channelElements = {};
    const lastMeterLevels = {};
    let masterMeterElement = null;

    // Visibility tracking (virtualization)
    const visibleChannels = new Set();
    let channelObserver = null;

    // Time slicing for meters
    let meterUpdateFrame = 0;

    let stemCount = 0;
    let isPlaying = false;
    let startTime = 0;
    let pauseTime = 0;
    let duration = 0;
    let animationFrame = null;
    let activeFader = null;
    let lastMeterTime = 0;
    let lastProgressTime = 0;

    // ========================================================================
    // DOM ELEMENTS
    // ========================================================================

    const $ = id => document.getElementById(id);
    const uploadView = $('uploadView');
    const dropZone = $('dropZone');
    const fileInput = $('fileInput');
    const fileList = $('fileList');
    const loadingSection = $('loadingSection');
    const loadingText = $('loadingText');
    const loadingProgressFill = $('loadingProgressFill');
    const loadingPercent = $('loadingPercent');
    const mixerPanel = $('mixerPanel');
    const channelsContainer = $('channelsContainer');
    const playBtn = $('playBtn');
    const playIcon = $('playIcon');
    const stopBtn = $('stopBtn');
    const restartBtn = $('restartBtn');
    const progressBar = $('progressBar');
    const progressFill = $('progressFill');
    const currentTimeEl = $('currentTime');
    const durationEl = $('duration');
    const holographCanvas = $('holographCanvas');
    const actionsSection = $('actionsSection');
    const resetBtn = $('resetBtn');
    const trackMeta = $('trackMeta');

    // ========================================================================
    // FILE HANDLING
    // ========================================================================

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', e => handleFiles(e.target.files));

    function handleFiles(files) {
      const audioFiles = Array.from(files).filter(f =>
        f.type.startsWith('audio/') || /\.(mp3|wav|flac|ogg|m4a|aac)$/i.test(f.name)
      );
      if (!audioFiles.length) return alert('Please drop audio files');
      loadAudioFiles(audioFiles);
    }

    // ========================================================================
    // AUDIO ENGINE
    // ========================================================================

    async function initAudio() {
      if (audioContext) return;
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      masterGain = audioContext.createGain();
      masterGain.gain.value = 0.8;

      masterMeter = audioContext.createAnalyser();
      masterMeter.fftSize = 256;

      impulseBuffer = createImpulse(2, 2);
      masterReverb = audioContext.createConvolver();
      masterReverb.buffer = impulseBuffer;

      const reverbGain = audioContext.createGain();
      reverbGain.gain.value = 0.5;
      masterReverb.connect(reverbGain);
      reverbGain.connect(masterGain);

      masterGain.connect(masterMeter);
      masterMeter.connect(audioContext.destination);

      masterWaveformBuffer = new Float32Array(masterMeter.frequencyBinCount);
    }

    function createImpulse(dur, decay) {
      const len = audioContext.sampleRate * dur;
      const buf = audioContext.createBuffer(2, len, audioContext.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const data = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
        }
      }
      return buf;
    }

    function createFilter(rolloff = -12) {
      const stages = Math.abs(rolloff) / 12;
      const filters = [];
      for (let i = 0; i < stages; i++) {
        const f = audioContext.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 20000;
        f.Q.value = 1;
        if (i > 0) filters[i - 1].connect(f);
        filters.push(f);
      }
      return {
        filters,
        input: filters[0],
        output: filters[filters.length - 1],
        get type() { return filters[0].type; },
        set type(t) { filters.forEach(f => f.type = t); },
        get frequency() { return filters[0].frequency; },
        get Q() { return filters[0].Q; },
        get rolloff() { return rolloff; },
        setType(t) { filters.forEach(f => f.type = t); },
        setFrequency(v, time) { filters.forEach(f => f.frequency.setTargetAtTime(v, time, 0.01)); },
        setQ(v, time) { filters.forEach(f => f.Q.setTargetAtTime(v, time, 0.01)); },
        connect(dest) { filters[filters.length - 1].connect(dest); },
        disconnect() { filters.forEach(f => f.disconnect()); }
      };
    }

    function createStemNodes(index, rolloff = -12) {
      const eq = {
        low: audioContext.createBiquadFilter(),
        mid: audioContext.createBiquadFilter(),
        high: audioContext.createBiquadFilter()
      };
      eq.low.type = 'lowshelf'; eq.low.frequency.value = 250;
      eq.mid.type = 'peaking'; eq.mid.frequency.value = 1000; eq.mid.Q.value = 1;
      eq.high.type = 'highshelf'; eq.high.frequency.value = 4000;

      const filter = createFilter(rolloff);

      const delay = {
        node: audioContext.createDelay(2),
        feedback: audioContext.createGain(),
        wet: audioContext.createGain(),
        dry: audioContext.createGain()
      };
      delay.node.delayTime.value = 0.25;
      delay.feedback.gain.value = 0.3;
      delay.wet.gain.value = 0;
      delay.dry.gain.value = 1;

      const reverbSend = audioContext.createGain();
      reverbSend.gain.value = 0;

      const panner = audioContext.createStereoPanner();
      const gain = audioContext.createGain();
      gain.gain.value = 0.8;

      const meter = audioContext.createAnalyser();
      meter.fftSize = 128;
      meters[index] = meter;
      meterBuffers[index] = new Float32Array(meter.frequencyBinCount);

      // Chain: EQ ‚Üí Filter ‚Üí Delay ‚Üí Panner ‚Üí Gain ‚Üí Meter ‚Üí Master
      eq.low.connect(eq.mid);
      eq.mid.connect(eq.high);
      eq.high.connect(filter.input);

      filter.output.connect(delay.dry);
      filter.output.connect(delay.node);
      delay.node.connect(delay.feedback);
      delay.feedback.connect(delay.node);
      delay.node.connect(delay.wet);
      delay.dry.connect(panner);
      delay.wet.connect(panner);

      panner.connect(gain);
      gain.connect(reverbSend);
      reverbSend.connect(masterReverb);
      gain.connect(meter);
      meter.connect(masterGain);

      return { eq, filter, delay, reverbSend, panner, gain, meter, input: eq.low };
    }

    async function loadAudioFiles(files) {
      await initAudio();

      // Clear existing
      Object.values(players).forEach(p => { if (p.source) p.source.disconnect(); });
      Object.keys(players).forEach(k => delete players[k]);
      Object.keys(meters).forEach(k => delete meters[k]);
      channelsContainer.innerHTML = '';
      duration = 0;
      stemCount = 0;

      uploadView.classList.add('hidden');
      loadingSection.classList.add('visible');
      updateLoadingProgress(0, files.length, 'Preparing...');

      const assignments = assignFiles(files);

      fileList.innerHTML = assignments.map(a =>
        `<div class="file-tag"><div class="status"></div>${a.file.name}</div>`
      ).join('');
      dropZone.classList.add('has-files');

      let loaded = 0;
      for (const { file, name, color, index } of assignments) {
        updateLoadingProgress(loaded, assignments.length, `Loading ${name}...`);

        try {
          const arrayBuf = await file.arrayBuffer();
          const audioBuf = await audioContext.decodeAudioData(arrayBuf);

          const nodes = createStemNodes(index);
          const state = {
            volume: 0.8,
            muted: false,
            solo: false,
            fx: JSON.parse(JSON.stringify(DEFAULT_FX))
          };

          players[index] = { buffer: audioBuf, source: null, nodes, state, name, color, file };

          if (audioBuf.duration > duration) duration = audioBuf.duration;
          stemCount++;
          loaded++;
        } catch (e) {
          console.warn('Failed to load:', file.name, e);
          loaded++;
        }
      }

      updateLoadingProgress(assignments.length, assignments.length, 'Complete!');
      await new Promise(r => setTimeout(r, 300));

      loadingSection.classList.remove('visible');
      buildUI();
      mixerPanel.classList.add('visible');
      actionsSection.style.display = 'flex';

      // Update header status to ONLINE
      $('statusText').textContent = 'ONLINE';

      durationEl.textContent = formatTime(duration);
      trackMeta.textContent = `${stemCount} stems ¬∑ ${formatTime(duration)}`;

      setupHolograph();
    }

    function updateLoadingProgress(loaded, total, text) {
      const percent = total > 0 ? Math.round((loaded / total) * 100) : 0;
      loadingProgressFill.style.width = `${percent}%`;
      loadingPercent.textContent = `${percent}%`;
      loadingText.textContent = text;
    }

    function assignFiles(files) {
      const assignments = [];
      const used = new Set();

      files.forEach((file, idx) => {
        const baseName = file.name.toLowerCase().replace(/\.[^/.]+$/, '').replace(/[_-]/g, '');
        const name = file.name.replace(/\.[^/.]+$/, '').substring(0, 12).toUpperCase();

        // Try to match preset for color only
        const preset = STEM_PRESETS.find(p =>
          !used.has(p.id) && (baseName.includes(p.id) || baseName.includes(p.name.toLowerCase()))
        );
        const color = preset ? preset.color : FALLBACK_COLORS[idx % FALLBACK_COLORS.length];
        if (preset) used.add(preset.id);

        assignments.push({ file, name, color, index: idx });
      });

      return assignments;
    }

    // ========================================================================
    // PLAYBACK
    // ========================================================================

    function play() {
      if (isPlaying || !stemCount) return;
      audioContext.resume();

      const offset = pauseTime;
      startTime = audioContext.currentTime - offset;

      Object.entries(players).forEach(([i, p]) => {
        const source = audioContext.createBufferSource();
        source.buffer = p.buffer;
        source.connect(p.nodes.input);
        source.start(0, offset);
        p.source = source;
        source.onended = () => {
          if (isPlaying && getCurrentTime() >= duration - 0.1) stop();
        };
      });

      isPlaying = true;
      updatePlayButton();
      startAnimation();
    }

    function pause() {
      if (!isPlaying) return;
      pauseTime = getCurrentTime();
      Object.values(players).forEach(p => {
        if (p.source) { p.source.stop(); p.source = null; }
      });
      isPlaying = false;
      updatePlayButton();
      stopAnimation();
    }

    function stop() {
      pause();
      pauseTime = 0;
      updateProgress();
    }

    function seek(time) {
      const was = isPlaying;
      if (isPlaying) pause();
      pauseTime = Math.max(0, Math.min(time, duration));
      updateProgress();
      if (was) play();
    }

    function getCurrentTime() {
      return isPlaying ? audioContext.currentTime - startTime : pauseTime;
    }

    // ========================================================================
    // MUTE / SOLO / GAINS
    // ========================================================================

    function toggleMute(index) {
      players[index].state.muted = !players[index].state.muted;
      updateGains();
      updateChannelStates();
    }

    function toggleSolo(index) {
      players[index].state.solo = !players[index].state.solo;
      updateGains();
      updateChannelStates();
    }

    function hasSolo() {
      return Object.values(players).some(p => p.state.solo);
    }

    function isStemActive(index, solo = null) {
      const state = players[index].state;
      if (state.muted) return false;
      const anySolo = solo !== null ? solo : hasSolo();
      if (anySolo && !state.solo) return false;
      return true;
    }

    function updateGains() {
      const solo = hasSolo();
      Object.entries(players).forEach(([i, p]) => {
        const active = isStemActive(i, solo);
        p.nodes.gain.gain.setTargetAtTime(active ? p.state.volume : 0, audioContext.currentTime, 0.05);
      });
    }

    function updateChannelStates() {
      const solo = hasSolo();
      Object.entries(players).forEach(([i, p]) => {
        const ch = $(`channel-${i}`);
        const active = isStemActive(i, solo);
        ch.classList.toggle('active', active);
        ch.classList.toggle('inactive', !active);
        $(`mute-${i}`).classList.toggle('active', p.state.muted);
        $(`solo-${i}`).classList.toggle('active', p.state.solo);
      });
    }

    // ========================================================================
    // UI BUILDING
    // ========================================================================

    function buildUI() {
      channelsContainer.innerHTML = '';

      // Clear previous observer
      if (channelObserver) {
        channelObserver.disconnect();
        visibleChannels.clear();
      }

      // Setup visibility observer (virtualization)
      channelObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const idx = entry.target.dataset.index;
          if (idx === undefined) return;
          if (entry.isIntersecting) {
            visibleChannels.add(idx);
          } else {
            visibleChannels.delete(idx);
          }
        });
      }, { root: null, rootMargin: '0px', threshold: 0 });

      Object.entries(players).forEach(([index, player]) => {
        const { state, name, color } = player;
        const i = parseInt(index);

        const ch = document.createElement('div');
        ch.className = 'channel active';
        ch.id = `channel-${i}`;
        ch.dataset.index = i;
        ch.style.setProperty('--channel-color', color);

        ch.innerHTML = `
          <span class="signal-led" id="led-${i}"></span>
          <div class="channel-name">${name}</div>
          <div class="stem-waveform"><canvas id="wave-${i}" width="60" height="28"></canvas></div>
          <div class="pan-control">
            <input type="range" min="-100" max="100" value="${state.fx.pan * 100}" class="pan-slider" id="pan-${i}">
            <div class="pan-label">PAN</div>
          </div>
          <div class="fader-container">
            <div class="meter"><div class="meter-fill" id="meter-${i}"></div></div>
            <div class="fader" id="fader-${i}">
              <div class="fader-fill" style="height:${state.volume*100}%"></div>
              <div class="fader-handle" style="bottom:${state.volume*100}%"></div>
            </div>
          </div>
          <div class="volume-readout" id="readout-${i}">${Math.round(state.volume*100)}%</div>
          <div class="channel-buttons">
            <button class="channel-btn mute" id="mute-${i}">M</button>
            <button class="channel-btn solo" id="solo-${i}">S</button>
          </div>
          <button class="channel-btn fx-btn" id="fxbtn-${i}">FX</button>
        `;

        channelsContainer.appendChild(ch);

        // Observe for visibility
        channelObserver.observe(ch);

        // Draw waveform
        drawWaveform(i, player.buffer, color);

        // Cache elements
        meterElements[i] = $(`meter-${i}`);
        channelElements[i] = ch;

        // Setup controls
        setupChannelControls(i);
      });

      // Master channel
      const master = document.createElement('div');
      master.className = 'master-channel';
      master.innerHTML = `
        <div class="master-label">MASTER</div>
        <div class="master-fader-container">
          <div class="master-meter"><div class="master-meter-fill" id="masterMeterFill"></div></div>
          <div class="master-fader" id="masterFader">
            <div class="fader-fill" style="height:80%"></div>
            <div class="fader-handle" style="bottom:80%"></div>
          </div>
        </div>
        <div class="master-volume-readout" id="masterReadout">80%</div>
      `;
      channelsContainer.appendChild(master);
      masterMeterElement = $('masterMeterFill');
      setupMasterFader();
    }

    function setupChannelControls(index) {
      $(`pan-${index}`).oninput = e => {
        const v = e.target.value / 100;
        players[index].state.fx.pan = v;
        players[index].nodes.panner.pan.setTargetAtTime(v, audioContext.currentTime, 0.01);
      };

      $(`mute-${index}`).onclick = () => toggleMute(index);
      $(`solo-${index}`).onclick = () => toggleSolo(index);
      $(`fxbtn-${index}`).onclick = () => openFxModal(index);

      setupFader($(`fader-${index}`), index);
    }

    function setupFader(faderEl, index) {
      const update = e => {
        const rect = faderEl.getBoundingClientRect();
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const val = Math.max(0, Math.min(1, 1 - y / rect.height));

        faderEl.querySelector('.fader-fill').style.height = `${val * 100}%`;
        faderEl.querySelector('.fader-handle').style.bottom = `${val * 100}%`;
        $(`readout-${index}`).textContent = `${Math.round(val * 100)}%`;

        players[index].state.volume = val;
        updateGains();
      };

      faderEl.onmousedown = e => { activeFader = update; update(e); };
      faderEl.ontouchstart = e => { activeFader = update; update(e); };
    }

    function setupMasterFader() {
      const fader = $('masterFader');
      const readout = $('masterReadout');

      const update = e => {
        const rect = fader.getBoundingClientRect();
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        const val = Math.max(0, Math.min(1, 1 - y / rect.height));

        fader.querySelector('.fader-fill').style.height = `${val * 100}%`;
        fader.querySelector('.fader-handle').style.bottom = `${val * 100}%`;
        readout.textContent = `${Math.round(val * 100)}%`;

        masterGain.gain.setTargetAtTime(val, audioContext.currentTime, 0.01);
      };

      fader.onmousedown = e => { activeFader = update; update(e); };
      fader.ontouchstart = e => { activeFader = update; update(e); };
    }

    window.addEventListener('mousemove', e => { if (activeFader) activeFader(e); });
    window.addEventListener('touchmove', e => { if (activeFader) { e.preventDefault(); activeFader(e); } }, { passive: false });
    window.addEventListener('mouseup', () => activeFader = null);
    window.addEventListener('touchend', () => activeFader = null);

    // ========================================================================
    // FX MODAL
    // ========================================================================

    const fxModalBackdrop = $('fxModalBackdrop');
    const fxModalTitle = $('fxModalTitle');
    const fxModalContent = $('fxModalContent');
    const fxModalClose = $('fxModalClose');
    const fxTabBtns = document.querySelectorAll('.fx-tab-btn');

    let activeFxIndex = null;
    let activeFxTab = 'eq-filter';

    function renderFxModalContent(index) {
      const player = players[index];
      if (!player) return '';

      const { state } = player;
      const fx = state.fx;

      return `
        <div class="fx-tab-content active" data-tab="eq-filter">
          <div class="fx-section">
            <span class="fx-section-label">EQUALIZER</span>
            <div class="fx-control">
              <span class="fx-label">Low</span>
              <input type="range" class="fx-slider" id="eq-low-${index}" min="-12" max="12" step="0.5" value="${fx.eq.low}">
              <span class="fx-value" id="eq-low-val-${index}">${fx.eq.low > 0 ? '+' : ''}${fx.eq.low.toFixed(1)}dB</span>
            </div>
            <div class="fx-control">
              <span class="fx-label">Mid</span>
              <input type="range" class="fx-slider" id="eq-mid-${index}" min="-12" max="12" step="0.5" value="${fx.eq.mid}">
              <span class="fx-value" id="eq-mid-val-${index}">${fx.eq.mid > 0 ? '+' : ''}${fx.eq.mid.toFixed(1)}dB</span>
            </div>
            <div class="fx-control">
              <span class="fx-label">High</span>
              <input type="range" class="fx-slider" id="eq-high-${index}" min="-12" max="12" step="0.5" value="${fx.eq.high}">
              <span class="fx-value" id="eq-high-val-${index}">${fx.eq.high > 0 ? '+' : ''}${fx.eq.high.toFixed(1)}dB</span>
            </div>
          </div>
          <div class="fx-section">
            <span class="fx-section-label">FILTER</span>
            <div class="fx-control">
              <span class="fx-label">Type</span>
              <select class="fx-select" id="flt-type-${index}">
                <option value="lowpass" ${fx.filter.type === 'lowpass' ? 'selected' : ''}>Lowpass</option>
                <option value="highpass" ${fx.filter.type === 'highpass' ? 'selected' : ''}>Highpass</option>
                <option value="bandpass" ${fx.filter.type === 'bandpass' ? 'selected' : ''}>Bandpass</option>
              </select>
              <span></span>
            </div>
            <div class="fx-control">
              <span class="fx-label">Slope</span>
              <select class="fx-select" id="flt-rolloff-${index}">
                <option value="-12" ${fx.filter.rolloff === -12 ? 'selected' : ''}>-12 dB/oct</option>
                <option value="-24" ${fx.filter.rolloff === -24 ? 'selected' : ''}>-24 dB/oct</option>
              </select>
              <span></span>
            </div>
            <div class="fx-control">
              <span class="fx-label">Freq</span>
              <input type="range" class="fx-slider" id="flt-freq-${index}" min="20" max="20000" value="${fx.filter.freq}">
              <span class="fx-value" id="flt-freq-val-${index}">${fx.filter.freq >= 1000 ? (fx.filter.freq/1000).toFixed(1) + 'kHz' : Math.round(fx.filter.freq) + 'Hz'}</span>
            </div>
            <div class="fx-control">
              <span class="fx-label">Q</span>
              <input type="range" class="fx-slider" id="flt-q-${index}" min="0.1" max="10" step="0.1" value="${fx.filter.q}">
              <span class="fx-value" id="flt-q-val-${index}">${fx.filter.q.toFixed(1)}</span>
            </div>
          </div>
        </div>
        <div class="fx-tab-content" data-tab="reverb-delay">
          <div class="fx-section">
            <span class="fx-section-label">REVERB</span>
            <div class="fx-control">
              <span class="fx-label">Send</span>
              <input type="range" class="fx-slider" id="reverb-${index}" min="0" max="100" value="${fx.reverb}">
              <span class="fx-value" id="reverb-val-${index}">${Math.round(fx.reverb)}%</span>
            </div>
          </div>
          <div class="fx-section">
            <span class="fx-section-label">DELAY</span>
            <div class="fx-control">
              <span class="fx-label">Time</span>
              <input type="range" class="fx-slider" id="dly-time-${index}" min="0.01" max="1" step="0.01" value="${fx.delay.time}">
              <span class="fx-value" id="dly-time-val-${index}">${Math.round(fx.delay.time * 1000)}ms</span>
            </div>
            <div class="fx-control">
              <span class="fx-label">Feedback</span>
              <input type="range" class="fx-slider" id="dly-fb-${index}" min="0" max="0.9" step="0.05" value="${fx.delay.feedback}">
              <span class="fx-value" id="dly-fb-val-${index}">${Math.round(fx.delay.feedback * 100)}%</span>
            </div>
            <div class="fx-control">
              <span class="fx-label">Mix</span>
              <input type="range" class="fx-slider" id="dly-mix-${index}" min="0" max="100" value="${fx.delay.mix}">
              <span class="fx-value" id="dly-mix-val-${index}">${Math.round(fx.delay.mix)}%</span>
            </div>
          </div>
        </div>
      `;
    }

    function setupFxModalListeners(index) {
      const player = players[index];
      if (!player) return;
      const { nodes, state } = player;
      const t = () => audioContext.currentTime;

      ['low', 'mid', 'high'].forEach(band => {
        const el = $(`eq-${band}-${index}`);
        if (el) {
          el.oninput = e => {
            const v = parseFloat(e.target.value);
            state.fx.eq[band] = v;
            const node = band === 'low' ? nodes.eq.low : band === 'mid' ? nodes.eq.mid : nodes.eq.high;
            node.gain.setTargetAtTime(v, t(), 0.01);
            $(`eq-${band}-val-${index}`).textContent = `${v > 0 ? '+' : ''}${v.toFixed(1)}dB`;
          };
        }
      });

      const fltType = $(`flt-type-${index}`);
      if (fltType) {
        fltType.onchange = e => {
          state.fx.filter.type = e.target.value;
          nodes.filter.setType(e.target.value);
        };
      }

      const fltRolloff = $(`flt-rolloff-${index}`);
      if (fltRolloff) {
        fltRolloff.onchange = e => {
          const newRolloff = parseInt(e.target.value);
          if (nodes.filter.rolloff === newRolloff) return;

          // Store current settings
          const { type, freq, q } = state.fx.filter;

          // Disconnect old filter
          nodes.eq.high.disconnect();
          nodes.filter.disconnect();

          // Create new filter with new rolloff
          const newFilter = createFilter(newRolloff);
          newFilter.setType(type);
          newFilter.setFrequency(freq, t());
          newFilter.setQ(q, t());

          // Reconnect: EQ ‚Üí Filter ‚Üí Delay
          nodes.eq.high.connect(newFilter.input);
          newFilter.output.connect(nodes.delay.dry);
          newFilter.output.connect(nodes.delay.node);

          // Update references
          nodes.filter = newFilter;
          state.fx.filter.rolloff = newRolloff;
        };
      }

      const fltFreq = $(`flt-freq-${index}`);
      if (fltFreq) {
        fltFreq.oninput = e => {
          const v = parseFloat(e.target.value);
          state.fx.filter.freq = v;
          nodes.filter.setFrequency(v, t());
          $(`flt-freq-val-${index}`).textContent = v >= 1000 ? `${(v/1000).toFixed(1)}kHz` : `${Math.round(v)}Hz`;
        };
      }

      const fltQ = $(`flt-q-${index}`);
      if (fltQ) {
        fltQ.oninput = e => {
          const v = parseFloat(e.target.value);
          state.fx.filter.q = v;
          nodes.filter.setQ(v, t());
          $(`flt-q-val-${index}`).textContent = v.toFixed(1);
        };
      }

      const reverbEl = $(`reverb-${index}`);
      if (reverbEl) {
        reverbEl.oninput = e => {
          const v = parseFloat(e.target.value);
          state.fx.reverb = v;
          nodes.reverbSend.gain.setTargetAtTime(v / 100, t(), 0.01);
          $(`reverb-val-${index}`).textContent = `${Math.round(v)}%`;
        };
      }

      const dlyTime = $(`dly-time-${index}`);
      if (dlyTime) {
        dlyTime.oninput = e => {
          const v = parseFloat(e.target.value);
          state.fx.delay.time = v;
          nodes.delay.node.delayTime.setTargetAtTime(v, t(), 0.01);
          $(`dly-time-val-${index}`).textContent = `${Math.round(v * 1000)}ms`;
        };
      }

      const dlyFb = $(`dly-fb-${index}`);
      if (dlyFb) {
        dlyFb.oninput = e => {
          const v = parseFloat(e.target.value);
          state.fx.delay.feedback = v;
          nodes.delay.feedback.gain.setTargetAtTime(v, t(), 0.01);
          $(`dly-fb-val-${index}`).textContent = `${Math.round(v * 100)}%`;
        };
      }

      const dlyMix = $(`dly-mix-${index}`);
      if (dlyMix) {
        dlyMix.oninput = e => {
          const v = parseFloat(e.target.value);
          state.fx.delay.mix = v;
          nodes.delay.wet.gain.setTargetAtTime(v / 100, t(), 0.01);
          nodes.delay.dry.gain.setTargetAtTime(1 - v / 100, t(), 0.01);
          $(`dly-mix-val-${index}`).textContent = `${Math.round(v)}%`;
        };
      }
    }

    function openFxModal(index) {
      const player = players[index];
      if (!player) return;

      activeFxIndex = index;
      activeFxTab = 'eq-filter';

      fxModalTitle.textContent = `${player.name} FX`;
      fxModalContent.innerHTML = renderFxModalContent(index);

      // Reset tabs
      fxTabBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === 'eq-filter'));
      fxModalContent.querySelectorAll('.fx-tab-content').forEach(c => {
        c.classList.toggle('active', c.dataset.tab === 'eq-filter');
      });

      setupFxModalListeners(index);
      fxModalBackdrop.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeFxModal() {
      fxModalBackdrop.classList.remove('active');
      activeFxIndex = null;
      document.body.style.overflow = '';
    }

    // FX Modal events
    fxModalClose.addEventListener('click', closeFxModal);
    fxModalBackdrop.addEventListener('click', e => {
      if (e.target === fxModalBackdrop) closeFxModal();
    });

    fxTabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const tabName = btn.dataset.tab;
        activeFxTab = tabName;

        fxTabBtns.forEach(b => b.classList.toggle('active', b.dataset.tab === tabName));
        fxModalContent.querySelectorAll('.fx-tab-content').forEach(c => {
          c.classList.toggle('active', c.dataset.tab === tabName);
        });
      });
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && activeFxIndex !== null) {
        closeFxModal();
      }
    });

    // ========================================================================
    // WAVEFORM
    // ========================================================================

    function drawWaveform(index, buffer, color) {
      const canvas = $(`wave-${index}`);
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const data = buffer.getChannelData(0);
      const step = Math.ceil(data.length / 60);
      const peaks = [];

      for (let i = 0; i < 60; i++) {
        let min = 1, max = -1;
        for (let j = 0; j < step; j++) {
          const v = data[(i * step) + j];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        peaks.push({ min, max });
      }

      ctx.clearRect(0, 0, 60, 28);
      ctx.fillStyle = color;

      const amp = 14;
      peaks.forEach((p, i) => {
        ctx.fillRect(i, (1 + p.min) * amp, 1, Math.max(1, (p.max - p.min) * amp));
      });
    }

    // ========================================================================
    // HOLOGRAPH VISUALIZER (Inline Worker)
    // ========================================================================

    const HOLOGRAPH_WORKER_CODE = `
      let canvas = null;
      let ctx = null;
      let width = 0;
      let height = 0;
      let colorMap = [];
      let themeColorRgb = null;

      const GRID_ROWS = 40;
      const GRID_COLS = 24;
      const GRID_SPACING = 30;

      let centerX = 0;
      let centerY = 0;
      const FOV = 300;
      const VIEW_DISTANCE = 150;

      let newRow = new Array(GRID_COLS);
      let points = [];
      let glowColor = '';
      let gridData = [];

      self.onmessage = function(e) {
        const { type, payload } = e.data;
        switch (type) {
          case 'init': init(payload); break;
          case 'resize': resize(payload); break;
          case 'draw': draw(payload); break;
        }
      };

      function init({ canvas: c, themeColor: color }) {
        canvas = c;
        ctx = canvas.getContext('2d', { alpha: false });
        const baseColor = color || '#4ECDC4';

        themeColorRgb = hexToRgb(baseColor);
        glowColor = 'rgb(' + themeColorRgb.r + ',' + themeColorRgb.g + ',' + themeColorRgb.b + ')';
        colorMap = generateGradient(baseColor);

        gridData = Array(GRID_ROWS).fill(0).map(() => Array(GRID_COLS).fill(0));
        points = Array(GRID_ROWS).fill(null).map(() =>
          Array(GRID_COLS).fill(null).map(() => ({ x: 0, y: 0, visible: false }))
        );
      }

      function resize({ width: w, height: h }) {
        width = w;
        height = h;
        canvas.width = width;
        canvas.height = height;
        centerX = width / 2;
        centerY = height / 2 - 40;
      }

      function draw({ frequency }) {
        if (!ctx || !width || !height) return;

        const bucketSize = Math.floor(frequency.length / GRID_COLS);
        let hasPeaks = false;

        for (let i = 0; i < GRID_COLS; i++) {
          let sum = 0;
          const start = i * bucketSize;
          for (let j = 0; j < bucketSize; j++) {
            sum += frequency[start + j];
          }
          const amp = Math.min(255, (sum / bucketSize) * 2.0);
          newRow[i] = amp;
          if (amp >= 160) hasPeaks = true;
        }

        const recycledRow = gridData.pop();
        gridData.unshift(newRow);
        newRow = recycledRow;

        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, width, height);

        for (let r = 0; r < GRID_ROWS; r++) {
          for (let c = 0; c < GRID_COLS; c++) {
            project(c, r, gridData[r][c], points[r][c]);
          }
        }

        const MID_THRESH = 60;
        const PEAK_THRESH = 160;

        ctx.beginPath();
        ctx.strokeStyle = colorMap[40];
        ctx.lineWidth = 1;
        drawGridLines(ctx, points, gridData, 0);
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = colorMap[120];
        ctx.lineWidth = 1.5;
        drawGridLines(ctx, points, gridData, MID_THRESH);
        ctx.stroke();

        if (hasPeaks) {
          ctx.save();
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          drawGridLines(ctx, points, gridData, PEAK_THRESH);
          ctx.stroke();
          ctx.restore();
        }

        drawNowLine(ctx, points);
      }

      function drawNowLine(ctx, points) {
        if (!points[0] || points[0].length === 0) return;
        const frontRow = points[0];

        ctx.beginPath();
        ctx.strokeStyle = glowColor;
        ctx.lineWidth = 6;
        for (let c = 0; c < GRID_COLS; c++) {
          const p = frontRow[c];
          if (!p.visible) continue;
          if (c === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        for (let c = 0; c < GRID_COLS; c++) {
          const p = frontRow[c];
          if (!p.visible) continue;
          if (c === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      function drawGridLines(ctx, points, gridData, minAmp) {
        for (let r = 0; r < GRID_ROWS; r++) {
          for (let c = 0; c < GRID_COLS; c++) {
            const p1 = points[r][c];
            if (!p1.visible) continue;
            const amp = gridData[r][c];

            if (c > 0) {
              const prevAmp = gridData[r][c-1];
              if (Math.max(amp, prevAmp) >= minAmp) {
                const p2 = points[r][c-1];
                if (p2.visible) {
                  ctx.moveTo(p1.x, p1.y);
                  ctx.lineTo(p2.x, p2.y);
                }
              }
            }

            if (r > 0) {
              const prevAmp = gridData[r-1][c];
              if (Math.max(amp, prevAmp) >= minAmp) {
                const p3 = points[r-1][c];
                if (p3.visible) {
                  ctx.moveTo(p1.x, p1.y);
                  ctx.lineTo(p3.x, p3.y);
                }
              }
            }
          }
        }
      }

      function project(c, r, amp, outPoint) {
        const x3d = (c - GRID_COLS / 2) * GRID_SPACING;
        const z3d = r * GRID_SPACING;
        const y3d = 60 - (amp * 0.7);
        const scale = FOV / (VIEW_DISTANCE + z3d);

        if (scale <= 0) {
          outPoint.visible = false;
          return;
        }

        outPoint.x = centerX + x3d * scale;
        outPoint.y = centerY + y3d * scale;
        outPoint.visible = true;
      }

      function generateGradient(hexColor) {
        const map = new Array(256);
        const rgb = hexToRgb(hexColor);
        const dim = { r: Math.floor(rgb.r * 0.6), g: Math.floor(rgb.g * 0.6), b: Math.floor(rgb.b * 0.6) };
        const white = { r: 255, g: 255, b: 255 };

        for (let i = 0; i < 256; i++) {
          let r, g, b;
          if (i < 100) {
            const f = i / 100;
            r = Math.floor(dim.r + (rgb.r - dim.r) * f);
            g = Math.floor(dim.g + (rgb.g - dim.g) * f);
            b = Math.floor(dim.b + (rgb.b - dim.b) * f);
          } else {
            const f = (i - 100) / 155;
            r = Math.floor(rgb.r + (white.r - rgb.r) * f);
            g = Math.floor(rgb.g + (white.g - rgb.g) * f);
            b = Math.floor(rgb.b + (white.b - rgb.b) * f);
          }
          map[i] = 'rgb(' + r + ',' + g + ',' + b + ')';
        }
        return map;
      }

      function hexToRgb(hex) {
        return {
          r: parseInt(hex.substring(1, 3), 16),
          g: parseInt(hex.substring(3, 5), 16),
          b: parseInt(hex.substring(5, 7), 16)
        };
      }
    `;

    let holographWorker = null;
    let holographDataBuffer = null;

    function setupHolograph() {
      if (!holographCanvas || !holographCanvas.transferControlToOffscreen) {
        console.warn('OffscreenCanvas not supported. Holograph disabled.');
        return;
      }

      try {
        const offscreen = holographCanvas.transferControlToOffscreen();
        const blob = new Blob([HOLOGRAPH_WORKER_CODE], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);

        holographWorker = new Worker(workerUrl);
        URL.revokeObjectURL(workerUrl);

        holographWorker.postMessage({
          type: 'init',
          payload: { canvas: offscreen, themeColor: '#4ECDC4' }
        }, [offscreen]);

        holographDataBuffer = new Uint8Array(masterMeter.frequencyBinCount);

        const rect = holographCanvas.getBoundingClientRect();
        const pixelRatio = window.devicePixelRatio || 1;
        holographWorker.postMessage({
          type: 'resize',
          payload: {
            width: Math.floor(rect.width * pixelRatio),
            height: Math.floor(rect.height * pixelRatio)
          }
        });
      } catch (e) {
        console.error('Failed to initialize Holograph:', e);
      }
    }

    function updateHolograph() {
      if (!holographWorker || !masterMeter || !holographDataBuffer) return;

      masterMeter.getByteFrequencyData(holographDataBuffer);
      holographWorker.postMessage({
        type: 'draw',
        payload: { frequency: holographDataBuffer }
      });
    }

    // ========================================================================
    // ANIMATION LOOP
    // ========================================================================

    function startAnimation() {
      const loop = now => {
        if (now - lastProgressTime > 100) {
          updateProgress();
          lastProgressTime = now;
        }
        if (now - lastMeterTime > 32) {
          updateMeters();
          updateHolograph();
          lastMeterTime = now;
        }
        if (isPlaying) animationFrame = requestAnimationFrame(loop);
      };
      loop(performance.now());
    }

    function stopAnimation() {
      if (animationFrame) { cancelAnimationFrame(animationFrame); animationFrame = null; }
    }

    function updateProgress() {
      const time = getCurrentTime();
      const pct = duration > 0 ? (time / duration) * 100 : 0;
      progressFill.style.width = `${pct}%`;
      currentTimeEl.textContent = formatTime(time);
    }

    function updateMeters() {
      meterUpdateFrame++;
      const frameParity = meterUpdateFrame % 2;
      const solo = hasSolo();

      Object.entries(meters).forEach(([i, meter]) => {
        const el = meterElements[i];
        if (!el) return;

        // Skip invisible channels (virtualization)
        if (!visibleChannels.has(i.toString())) return;

        // Time slicing: update half the meters per frame
        if (parseInt(i) % 2 !== frameParity) return;

        if (!isStemActive(i, solo) || !isPlaying) {
          if (lastMeterLevels[i] !== 0) {
            el.style.transform = 'scaleY(0)';
            lastMeterLevels[i] = 0;
            channelElements[i]?.classList.remove('has-signal');
          }
          return;
        }

        const buf = meterBuffers[i];
        meter.getFloatTimeDomainData(buf);

        let sum = 0;
        for (let j = 0; j < buf.length; j++) sum += buf[j] * buf[j];
        const rms = Math.sqrt(sum / buf.length);
        const db = 20 * Math.log10(rms + 0.0001);
        const norm = Math.max(0, Math.min(1, (db + 60) / 60));

        // Dirty check: only update DOM if value changed significantly
        if (Math.abs((lastMeterLevels[i] || 0) - norm) < 0.01) return;
        lastMeterLevels[i] = norm;

        el.style.transform = `scaleY(${norm})`;
        channelElements[i]?.classList.toggle('has-signal', norm > 0.05);
      });

      if (masterMeterElement && isPlaying) {
        masterMeter.getFloatTimeDomainData(masterWaveformBuffer);
        let sum = 0;
        for (let j = 0; j < masterWaveformBuffer.length; j++) sum += masterWaveformBuffer[j] * masterWaveformBuffer[j];
        const rms = Math.sqrt(sum / masterWaveformBuffer.length);
        const db = 20 * Math.log10(rms + 0.0001);
        const norm = Math.max(0, Math.min(1, (db + 60) / 60));
        masterMeterElement.style.transform = `scaleY(${norm})`;
      } else if (masterMeterElement) {
        masterMeterElement.style.transform = 'scaleY(0)';
      }
    }

    $('backBtn').addEventListener('click', () => {
      // Stop playback
      if (isPlaying) stop();

      // Clear players and meters
      Object.values(players).forEach(p => { if (p.source) p.source.disconnect(); });
      Object.keys(players).forEach(k => delete players[k]);
      Object.keys(meters).forEach(k => delete meters[k]);
      channelsContainer.innerHTML = '';
      duration = 0;
      stemCount = 0;

      // Reset UI
      mixerPanel.classList.remove('visible');
      actionsSection.style.display = 'none';
      uploadView.classList.remove('hidden');
      fileList.innerHTML = '';
      $('statusText').textContent = 'STANDBY';
      currentTimeEl.textContent = '0:00';
      durationEl.textContent = '0:00';
      progressFill.style.width = '0%';
      trackMeta.textContent = 'Drop stems to begin';
    });

    resetBtn.addEventListener('click', () => {
      const t = audioContext.currentTime;
      Object.entries(players).forEach(([index, p]) => {
        p.state.volume = 0.8;
        p.state.muted = false;
        p.state.solo = false;
        p.state.fx = JSON.parse(JSON.stringify(DEFAULT_FX));

        // Reset audio nodes to match default state
        const { nodes } = p;
        nodes.eq.low.gain.setTargetAtTime(0, t, 0.01);
        nodes.eq.mid.gain.setTargetAtTime(0, t, 0.01);
        nodes.eq.high.gain.setTargetAtTime(0, t, 0.01);

        // Reset filter (including rolloff if changed)
        if (nodes.filter.rolloff !== -12) {
          nodes.eq.high.disconnect();
          nodes.filter.disconnect();
          const newFilter = createFilter(-12);
          nodes.eq.high.connect(newFilter.input);
          newFilter.output.connect(nodes.delay.dry);
          newFilter.output.connect(nodes.delay.node);
          nodes.filter = newFilter;
        }
        nodes.filter.setType('lowpass');
        nodes.filter.setFrequency(20000, t);
        nodes.filter.setQ(1, t);

        nodes.reverbSend.gain.setTargetAtTime(0, t, 0.01);
        nodes.delay.node.delayTime.setTargetAtTime(0.25, t, 0.01);
        nodes.delay.feedback.gain.setTargetAtTime(0.3, t, 0.01);
        nodes.delay.wet.gain.setTargetAtTime(0, t, 0.01);
        nodes.panner.pan.setTargetAtTime(0, t, 0.01);
        nodes.gain.gain.setTargetAtTime(0.8, t, 0.01);
      });
      masterGain.gain.setTargetAtTime(0.8, t, 0.01);
      updateGains();
      updateChannelStates();
      buildUI();
    });

    // ========================================================================
    // TRANSPORT CONTROLS
    // ========================================================================

    playBtn.addEventListener('click', () => isPlaying ? pause() : play());
    stopBtn.addEventListener('click', stop);
    restartBtn.addEventListener('click', () => { stop(); play(); });
    $('skipBackBtn').addEventListener('click', () => seek(getCurrentTime() - 10));
    $('skipFwdBtn').addEventListener('click', () => seek(getCurrentTime() + 10));
    progressBar.addEventListener('click', e => {
      const rect = progressBar.getBoundingClientRect();
      seek((e.clientX - rect.left) / rect.width * duration);
    });

    function updatePlayButton() {
      playIcon.innerHTML = isPlaying
        ? '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'
        : '<path d="M8 5v14l11-7z"/>';
    }

    // ========================================================================
    // KEYBOARD SHORTCUTS
    // ========================================================================

    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
      switch (e.code) {
        case 'Space': e.preventDefault(); isPlaying ? pause() : play(); break;
        case 'Enter': e.preventDefault(); stop(); play(); break;
        case 'Escape': stop(); break;
        case 'ArrowLeft': seek(getCurrentTime() - 5); break;
        case 'ArrowRight': seek(getCurrentTime() + 5); break;
      }
    });

    // ========================================================================
    // UTILITIES
    // ========================================================================

    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    // ========================================================================
    // HELP SYSTEM
    // ========================================================================

    const helpBackdrop = $('helpBackdrop');
    const helpModal = $('helpModal');
    const helpBtn = $('helpBtn');
    const helpClose = $('helpClose');
    const helpDismiss = $('helpDismiss');
    const helpTabs = document.querySelectorAll('.help-tab');
    const helpTabContents = document.querySelectorAll('.help-tab-content');

    let helpIsOpen = false;
    let helpIsMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
      || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // Swipe state
    let helpStartY = 0;
    let helpCurrentY = 0;
    let helpIsDragging = false;

    function openHelp() {
      helpIsOpen = true;
      helpBackdrop.classList.add('active');
      helpModal.style.transform = '';
      document.body.style.overflow = 'hidden';
    }

    function closeHelp() {
      helpIsOpen = false;
      helpBackdrop.classList.remove('active');
      document.body.style.overflow = '';
    }

    function toggleHelp() {
      helpIsOpen ? closeHelp() : openHelp();
    }

    function switchHelpTab(tabId) {
      helpTabs.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabId);
      });
      helpTabContents.forEach(content => {
        content.classList.toggle('active', content.dataset.tab === tabId);
      });
    }

    // Theme toggle
    $('themeToggle').addEventListener('click', () => {
      const newTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('evr-theme', newTheme);
    });

    // Event listeners
    helpBtn.addEventListener('click', toggleHelp);
    helpClose.addEventListener('click', closeHelp);
    helpDismiss.addEventListener('click', closeHelp);

    helpBackdrop.addEventListener('click', e => {
      if (e.target === helpBackdrop) closeHelp();
    });

    helpTabs.forEach(tab => {
      tab.addEventListener('click', () => switchHelpTab(tab.dataset.tab));
    });

    // Keyboard shortcut for help
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        toggleHelp();
      }
      if (e.key === 'Escape' && helpIsOpen) {
        closeHelp();
      }
    });

    // Mobile swipe-to-dismiss
    if (helpIsMobile) {
      const helpHandle = helpModal.querySelector('.help-handle');

      const onSwipeStart = e => {
        helpIsDragging = true;
        helpStartY = e.touches ? e.touches[0].clientY : e.clientY;
        helpCurrentY = 0;
        helpModal.style.transition = 'none';
      };

      const onSwipeMove = e => {
        if (!helpIsDragging) return;
        const y = e.touches ? e.touches[0].clientY : e.clientY;
        helpCurrentY = Math.max(0, y - helpStartY);
        helpModal.style.transform = `translateY(${helpCurrentY}px)`;
      };

      const onSwipeEnd = () => {
        if (!helpIsDragging) return;
        helpIsDragging = false;
        helpModal.style.transition = '';

        if (helpCurrentY > 100) {
          closeHelp();
        } else {
          helpModal.style.transform = '';
        }
      };

      helpHandle.addEventListener('touchstart', onSwipeStart, { passive: true });
      helpHandle.addEventListener('mousedown', onSwipeStart);
      document.addEventListener('touchmove', onSwipeMove, { passive: true });
      document.addEventListener('mousemove', onSwipeMove);
      document.addEventListener('touchend', onSwipeEnd);
      document.addEventListener('mouseup', onSwipeEnd);
    }
  </script>
</body>
</html>
